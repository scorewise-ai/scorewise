# ScoreWise AI - Main FastAPI Application - FINAL VERSION

import os
import json
import uuid
import asyncio
import shutil
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Dict, Union, Any
import aiofiles
import hashlib

from fastapi import FastAPI, Request, Response, HTTPException, Depends, Form, File, UploadFile, BackgroundTasks
from fastapi.responses import HTMLResponse, JSONResponse, RedirectResponse, FileResponse
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware
from starlette.middleware.sessions import SessionMiddleware
import stripe
import requests
from pydantic import BaseModel
import uvicorn

from db import SessionLocal, Base, engine
from sqlalchemy import Column, String, DateTime
from sqlalchemy.orm import Session

# Import the fixed grader
from grader import grader

# Environment variables
from dotenv import load_dotenv
load_dotenv()

# Check environment variables
required_vars = ["STRIPE_SECRET_KEY", "STRIPE_PUBLISHABLE_KEY", "PERPLEXITY_API_KEY"]
missing_vars = [var for var in required_vars if not os.getenv(var)]
if missing_vars:
    raise Exception(f"Missing required environment variables: {', '.join(missing_vars)}")

# Configuration
SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key-here")
STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY")
STRIPE_PUBLISHABLE_KEY = os.getenv("STRIPE_PUBLISHABLE_KEY")
PERPLEXITY_API_KEY = os.getenv("PERPLEXITY_API_KEY")
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")

# Stripe Price IDs
PRICE_ID_STANDARD = os.getenv("PRICE_ID_STANDARD")
PRICE_ID_PRO = os.getenv("PRICE_ID_PRO")
PRICE_ID_ENTERPRISE = os.getenv("PRICE_ID_ENTERPRISE")

# Configure Stripe
stripe.api_key = STRIPE_SECRET_KEY

# Create directories
os.makedirs("uploads", exist_ok=True)
os.makedirs("static", exist_ok=True)
os.makedirs("templates", exist_ok=True)

# FastAPI app
app = FastAPI(title="ScoreWise AI", description="AI-Powered STEM Assignment Grading Platform")

# Middleware
app.add_middleware(SessionMiddleware, secret_key=SECRET_KEY)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Static files and templates
app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

# Models
class GradingTask(BaseModel):
    task_id: str
    subject: str
    status: str = "processing"
    created_at: datetime
    user_id: str
    files: Dict[str, Union[str, List[str]]] = {}
    results: Optional[Dict] = None
    error: Optional[str] = None

class User(Base):
    __tablename__ = "users"
    id = Column(String, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    password_hash = Column(String, nullable=False)
    subscription_status = Column(String, default="trial")
    created_at = Column(DateTime)

# Create database tables
Base.metadata.create_all(bind=engine)

# In-memory storage for tasks
tasks_storage: Dict[str, GradingTask] = {}

# STEM subjects list for validation
VALID_STEM_SUBJECTS = ["algebra", "biology", "calculus", "chemistry", "engineering", "physics"]

# Utility functions
def get_current_user(request: Request) -> Optional[Dict]:
    return request.session.get("user")

def require_auth(request: Request):
    user = get_current_user(request)
    if not user:
        return RedirectResponse(url="/?login=required", status_code=303)
    return user

def has_active_subscription(user: Dict) -> bool:
    status = user.get("subscription_status", "")
    return status in ["active", "trial"]

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

async def save_task_metadata(task_id: str, task_data: Dict):
    """Save task metadata to file"""
    try:
        task_dir = Path(f"uploads/{task_id}")
        task_dir.mkdir(exist_ok=True)
        async with aiofiles.open(task_dir / "metadata.json", "w") as f:
            await f.write(json.dumps(task_data, default=str))
    except Exception as e:
        print(f"Error saving task metadata: {str(e)}")
        raise

async def load_task_metadata(task_id: str) -> Optional[Dict]:
    """Load task metadata from file"""
    try:
        async with aiofiles.open(f"uploads/{task_id}/metadata.json", "r") as f:
            content = await f.read()
            return json.loads(content)
    except:
        return None

# Routes
@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    user = get_current_user(request)
    return templates.TemplateResponse("index.html", {
        "request": request,
        "user": user,
        "stripe_publishable_key": STRIPE_PUBLISHABLE_KEY
    })

@app.get("/pricing", response_class=HTMLResponse)
async def pricing(request: Request):
    user = get_current_user(request)
    return templates.TemplateResponse("pricing.html", {
        "request": request,
        "user": user,
        "stripe_publishable_key": STRIPE_PUBLISHABLE_KEY,
        "price_ids": {
            "standard": PRICE_ID_STANDARD,
            "pro": PRICE_ID_PRO,
            "enterprise": PRICE_ID_ENTERPRISE
        }
    })

@app.get("/upload", response_class=HTMLResponse)
async def upload_page(request: Request):
    user = require_auth(request)
    if isinstance(user, RedirectResponse):
        return user
    
    if not has_active_subscription(user):
        return RedirectResponse(url="/pricing", status_code=303)
    
    return templates.TemplateResponse("uploadfile.html", {
        "request": request,
        "user": user,
        "valid_subjects": VALID_STEM_SUBJECTS
    })

@app.get("/dashboard", response_class=HTMLResponse)
async def dashboard(request: Request):
    user = require_auth(request)
    if isinstance(user, RedirectResponse):
        return user
    
    if not has_active_subscription(user):
        return RedirectResponse(url="/pricing", status_code=303)
    
    # Get user's recent tasks
    user_tasks = []
    for task_id, task in tasks_storage.items():
        if task.user_id == user.get("id"):
            user_tasks.append(task)
    
    return templates.TemplateResponse("dashboard.html", {
        "request": request,
        "user": user,
        "tasks": sorted(user_tasks, key=lambda x: x.created_at, reverse=True)[:10]
    })

@app.post("/api/upload")
async def upload_files(
    request: Request,
    background_tasks: BackgroundTasks,
    subject: str = Form(...),
    assignment_file: UploadFile = File(...),
    student_submissions: List[UploadFile] = File(...),
    solution_file: Optional[UploadFile] = File(None),
    custom_rubric: Optional[UploadFile] = File(None)
):
    try:
        user = require_auth(request)
        if isinstance(user, RedirectResponse):
            raise HTTPException(status_code=401, detail="Authentication required")
        
        if not has_active_subscription(user):
            raise HTTPException(status_code=402, detail="Active subscription required")
        
        # Validate STEM subject
        if subject not in VALID_STEM_SUBJECTS:
            raise HTTPException(status_code=400, detail=f"Invalid subject. Must be one of: {', '.join(VALID_STEM_SUBJECTS)}")
        
        # Validate files
        all_files = [assignment_file] + student_submissions
        if solution_file:
            all_files.append(solution_file)
        if custom_rubric:
            all_files.append(custom_rubric)

        for file in all_files:
            if not file.filename:
                raise HTTPException(status_code=400, detail="Please select files to upload")
            
            if not file.filename.lower().endswith('.pdf'):
                raise HTTPException(status_code=400, detail=f"Only PDF files allowed. '{file.filename}' is not a PDF")
            
            if file.size and file.size > 10 * 1024 * 1024:
                raise HTTPException(status_code=400, detail=f"File '{file.filename}' exceeds 10MB limit")

        # Create task
        task_id = str(uuid.uuid4())
        task_dir = Path(f"uploads/{task_id}")
        task_dir.mkdir(exist_ok=True)
        
        # Save files
        saved_files = {}
        
        # Save assignment file
        assignment_path = task_dir / f"assignment_{assignment_file.filename}"
        async with aiofiles.open(assignment_path, "wb") as f:
            content = await assignment_file.read()
            await f.write(content)
        saved_files["assignment"] = str(assignment_path)

        # Save student submissions
        submissions_dir = task_dir / "submissions"
        submissions_dir.mkdir(exist_ok=True)
        submission_paths = []
        
        for i, submission in enumerate(student_submissions):
            submission_path = submissions_dir / f"submission_{i+1}_{submission.filename}"
            async with aiofiles.open(submission_path, "wb") as f:
                content = await submission.read()
                await f.write(content)
            submission_paths.append(str(submission_path))
        
        saved_files["submissions"] = submission_paths

        # Save optional files
        if solution_file:
            solution_path = task_dir / f"solution_{solution_file.filename}"
            async with aiofiles.open(solution_path, "wb") as f:
                content = await solution_file.read()
                await f.write(content)
            saved_files["solution"] = str(solution_path)

        if custom_rubric:
            rubric_path = task_dir / f"rubric_{custom_rubric.filename}"
            async with aiofiles.open(rubric_path, "wb") as f:
                content = await custom_rubric.read()
                await f.write(content)
            saved_files["rubric"] = str(rubric_path)

        # Create task record
        task_data = {
            "task_id": task_id,
            "subject": subject,
            "status": "processing",
            "created_at": datetime.now().isoformat(),
            "user_id": user.get("id"),
            "files": saved_files
        }

        # Save task metadata
        await save_task_metadata(task_id, task_data)
        
        # Create GradingTask object
        grading_task = GradingTask(
            task_id=task_id,
            subject=subject,
            status="processing",
            created_at=datetime.now(),
            user_id=user.get("id"),
            files=saved_files
        )
        tasks_storage[task_id] = grading_task
        
        # Start grading process in background
        background_tasks.add_task(process_grading_task, task_id)

        return {"task_id": task_id, "status": "processing", "message": "Upload successful, grading started"}

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail="Upload failed. Please try again.")

async def process_grading_task(task_id: str):
    """Process grading task using Perplexity API via grader.py"""
    try:
        # Load task data
        task_data = await load_task_metadata(task_id)
        if not task_data:
            return
        
        # Update status to indicate processing has started
        if task_id in tasks_storage:
            tasks_storage[task_id].status = "processing"
        
        # Use the grader
        results = await grader.grade_assignment(task_data)
        
        # Update task with results
        task_data["status"] = results.get("status", "completed")
        task_data["results"] = results
        await save_task_metadata(task_id, task_data)

        if task_id in tasks_storage:
            tasks_storage[task_id].status = results.get("status", "completed")
            tasks_storage[task_id].results = results
        
    except Exception as e:
        # Handle errors
        try:
            task_data = await load_task_metadata(task_id)
            if task_data:
                task_data["status"] = "error"
                task_data["error"] = str(e)
                await save_task_metadata(task_id, task_data)

            if task_id in tasks极orage:
                tasks_storage[task_id].status = "error"
                tasks_storage[task_id].error = str(e)
        except:
            pass

@app.get("/api/download-reports/{task_id}")
async def download_reports(task_id: str, request: Request, background_tasks: BackgroundTasks):
    user = require_auth(request)
    if isinstance(user, RedirectResponse):
        raise HTTPException(status_code=401, detail="Authentication required")
    
    # Load task metadata to verify ownership
    task_data = await load_task_metadata(task_id)
    if not task_data:
        raise HTTPException(status_code=404, detail="Task not found")
    
    if task_data.get("user_id") != user.get("id"):
        raise HTTPException(status_code=403, detail="Access denied")
    
    # Check if reports ZIP exists
    zip_path = Path(f"uploads/{task_id}/all_reports.zip")
    if not zip_path.exists():
        raise HTTPException(status_code=404, detail="Reports not available")
    
    # Schedule cleanup after response is sent
    def cleanup():
        try:
            shutil.rmtree(f"uploads/{task_id}")
            print(f"✓ Cleaned up uploads/{task_id} after download")
        except Exception as e:
            print(f"✗ Error cleaning up uploads/{task_id}: {e}")
    
    background_tasks.add_task(cleanup)
    
    return FileResponse(zip_path, filename=f"reports_{task_id}.zip")

@app.get("/api/task/{task_id}")
async def get_task_status(task_id: str, request: Request):
    user = require_auth(request)
    if isinstance(user, RedirectResponse):
        raise HTTPException(status_code=401, detail="Authentication required")

    task_data = await load_task_metadata(task_id)
    if not task_data:
        raise HTTPException(status_code=404, detail="Task not found")

    # Check if user owns this task
    if task_data.get("user_id") != user.get("id"):
        raise HTTPException(status_code=403, detail="Access denied")

    return task_data

@app.post("/api/create-checkout-session")
async def create_checkout_session(request: Request, plan: str = Form(...)):
    user = get_current_user(request)
    
    price_ids = {
        "standard": PRICE_ID_STANDARD,
        "pro": PRICE_ID_PRO,
        "enterprise": PRICE_ID_ENTERPRISE
    }

    if plan not in price_ids:
        raise HTTPException(status_code=400, detail="Invalid plan")

    try:
        session = stripe.checkout.Session.create(
            payment_method_types=["card"],
            mode="subscription",
            line_items=[{
                "price": price_ids[plan],
                "quantity": 1,
            }],
            success_url=request.url_for("success") + "?session_id={CHECKOUT_SESSION_ID}",
            cancel_url=request.url_for("pricing"),
            client_reference_id=user.get("id") if user else None,
        )

        return {"checkout_url": session.url}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/success", response_class=HTMLResponse)
async def success(request: Request, session_id: Optional[str] = None):
    return templates.TemplateResponse("success.html", {
        "request": request,
        "session_id": session_id
    })

@app.post("/webhook")
async def stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(
            payload, sig_header, STRIPE_WEBHOOK_SECRET
        )
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid payload")
    except stripe.error.SignatureVerificationError:
        raise HTTPException(status_code=400, detail="Invalid signature")

    # Handle the event
    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        # Update user subscription status
        # Implementation depends on your user management system
        pass

    return {"status": "success"}

# Authentication routes
@app.post("/auth/login")
async def login(
    request: Request,
    email: str = Form(...),
    password: str = Form(...),
    db: Session = Depends(get_db)
):
    user = db.query(User).filter(User.email == email).first()
    if user and user.password_hash == hashlib.sha256(password.encode()).hexdigest():
        request.session["user"] = {
            "id": user.id,
            "email": user.email,
            "subscription_status": user.subscription_status
        }
        return RedirectResponse(url="/dashboard", status_code=303)
    return templates.TemplateResponse("index.html", {"request": request, "login_error": "Invalid credentials"})

@app.post("/auth/logout")
async def logout(request: Request):
    request.session.clear()
    return RedirectResponse(url="/", status_code=303)

@app.get("/register", response_class=HTMLResponse)
async def register_page(request: Request):
    return templates.TemplateResponse("register.html", {
        "request": request
    })

@app.post("/auth/register")
async def register(
    request: Request,
    email: str = Form(...),
    password: str = Form(...),
    confirm_password: str = Form(...),
    db: Session = Depends(get_db)
):
    errors = []
    if password != confirm_password:
        errors.append("Passwords do not match")
    if len(password) < 8:
        errors.append("Password must be at least 8 characters")
    if db.query(User).filter(User.email == email).first():
        errors.append("Email already registered")
    if errors:
        return templates.TemplateResponse("register.html", {"request": request, "errors": errors})

    password_hash = hashlib.sha256(password.encode()).hexdigest()
    user = User(
        id=str(uuid.uuid4()),
        email=email,
        password_hash=password_hash,
        subscription_status="trial",
        created_at=datetime.now()
    )

    db.add(user)
    db.commit()
    db.refresh(user)

    request.session["user"] = {
        "id": user.id,
        "email": user.email,
        "subscription_status": user.subscription_status
    }

    return RedirectResponse(url="/pricing", status_code=303)

# Health check
@app.get("/health")
async def health_check():
    return {"status": "healthy", "timestamp": datetime.now().isoformat()}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)

